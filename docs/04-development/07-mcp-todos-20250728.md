# MCP (Model Context Protocol) é›†æˆSimaCodeå¼€å‘è®¡åˆ’

**æ—¥æœŸ**: 2025-07-28  
**ç‰ˆæœ¬**: v1.0  
**ç›®æ ‡**: é€šè¿‡MCPåè®®é›†æˆç¬¬ä¸‰æ–¹æ’ä»¶ï¼Œæ‰©å±•SimaCodeå·¥å…·ç”Ÿæ€ç³»ç»Ÿ  

## ğŸ¯ MCP é›†æˆä»·å€¼åˆ†æ

### MCPåè®®ä¼˜åŠ¿
- **æ ‡å‡†åŒ–åè®®**: Anthropicå¼€å‘çš„å¼€æ”¾åè®®ï¼Œç¡®ä¿äº’æ“ä½œæ€§
- **ä¸°å¯Œç”Ÿæ€**: å¯å¤ç”¨å¤§é‡ç°æœ‰MCPæœåŠ¡å™¨ï¼ˆGitHubã€æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“ç­‰ï¼‰
- **å®‰å…¨æœºåˆ¶**: å†…ç½®çš„å·¥å…·è°ƒç”¨å®‰å…¨éªŒè¯
- **å®æ—¶èƒ½åŠ›**: æ”¯æŒWebSocketå’Œæ ‡å‡†è¾“å…¥/è¾“å‡ºé€šä¿¡

### ä¸SimaCodeçš„å¥‘åˆç‚¹
- **å·¥å…·æ‰©å±•**: æ— éœ€é‡æ–°å¼€å‘å³å¯è·å¾—å¤§é‡ç¬¬ä¸‰æ–¹å·¥å…·
- **ç»Ÿä¸€æ¥å£**: MCPå·¥å…·å¯æ— ç¼é›†æˆåˆ°ç°æœ‰Toolç³»ç»Ÿ
- **ReActå¢å¼º**: ä¸ºReActå¼•æ“æä¾›æ›´å¤šå¯ç”¨å·¥å…·é€‰æ‹©

## ğŸ—ï¸ MCPå®¢æˆ·ç«¯æ¶æ„è®¾è®¡

### æ ¸å¿ƒç»„ä»¶æ¶æ„
```
SimaCode + MCP Integration
â”œâ”€â”€ src/simacode/mcp/
â”‚   â”œâ”€â”€ __init__.py                 # MCPæ¨¡å—å…¥å£
â”‚   â”œâ”€â”€ client.py                   # MCPå®¢æˆ·ç«¯æ ¸å¿ƒ
â”‚   â”œâ”€â”€ server_manager.py           # MCPæœåŠ¡å™¨ç®¡ç†
â”‚   â”œâ”€â”€ tool_wrapper.py             # MCPå·¥å…·åŒ…è£…å™¨
â”‚   â”œâ”€â”€ protocol.py                 # MCPåè®®å®ç°
â”‚   â”œâ”€â”€ config.py                   # MCPé…ç½®ç®¡ç†
â”‚   â””â”€â”€ exceptions.py               # MCPå¼‚å¸¸å®šä¹‰
â”œâ”€â”€ src/simacode/tools/
â”‚   â””â”€â”€ mcp_tool.py                 # MCPå·¥å…·é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ
â””â”€â”€ config/
    â””â”€â”€ mcp_servers.yaml            # MCPæœåŠ¡å™¨é…ç½®æ–‡ä»¶
```

### 1. **MCPå®¢æˆ·ç«¯æ ¸å¿ƒ** (`mcp/client.py`)

```python
class MCPClient:
    """MCPåè®®å®¢æˆ·ç«¯å®ç°"""
    
    def __init__(self, server_config: MCPServerConfig):
        self.server_config = server_config
        self.connection = None
        self.tools_cache = {}
        self.resources_cache = {}
    
    async def connect(self) -> bool:
        """è¿æ¥åˆ°MCPæœåŠ¡å™¨"""
        
    async def disconnect(self) -> None:
        """æ–­å¼€MCPæœåŠ¡å™¨è¿æ¥"""
        
    async def list_tools(self) -> List[MCPTool]:
        """è·å–æœåŠ¡å™¨å¯ç”¨å·¥å…·åˆ—è¡¨"""
        
    async def call_tool(self, name: str, arguments: Dict) -> MCPResult:
        """è°ƒç”¨MCPå·¥å…·"""
        
    async def list_resources(self) -> List[MCPResource]:
        """è·å–æœåŠ¡å™¨å¯ç”¨èµ„æºåˆ—è¡¨"""
```

### 2. **MCPæœåŠ¡å™¨ç®¡ç†å™¨** (`mcp/server_manager.py`)

```python
class MCPServerManager:
    """ç®¡ç†å¤šä¸ªMCPæœåŠ¡å™¨è¿æ¥"""
    
    def __init__(self):
        self.servers: Dict[str, MCPClient] = {}
        self.config_manager = MCPConfigManager()
    
    async def load_servers_from_config(self) -> None:
        """ä»é…ç½®æ–‡ä»¶åŠ è½½MCPæœåŠ¡å™¨"""
        
    async def add_server(self, name: str, config: MCPServerConfig) -> bool:
        """åŠ¨æ€æ·»åŠ MCPæœåŠ¡å™¨"""
        
    async def remove_server(self, name: str) -> bool:
        """ç§»é™¤MCPæœåŠ¡å™¨"""
        
    async def get_all_tools(self) -> Dict[str, List[MCPTool]]:
        """è·å–æ‰€æœ‰æœåŠ¡å™¨çš„å·¥å…·"""
        
    async def call_tool(self, server_name: str, tool_name: str, args: Dict) -> MCPResult:
        """è°ƒç”¨æŒ‡å®šæœåŠ¡å™¨çš„å·¥å…·"""
```

### 3. **MCPå·¥å…·åŒ…è£…å™¨** (`mcp/tool_wrapper.py`)

```python
class MCPToolWrapper(Tool):
    """å°†MCPå·¥å…·åŒ…è£…æˆSimaCode Tool"""
    
    def __init__(self, mcp_tool: MCPTool, server_manager: MCPServerManager):
        self.mcp_tool = mcp_tool
        self.server_manager = server_manager
        super().__init__(
            name=f"mcp_{mcp_tool.server_name}_{mcp_tool.name}",
            description=mcp_tool.description,
            version="1.0.0"
        )
    
    async def execute(self, input_data: ToolInput) -> AsyncGenerator[ToolResult, None]:
        """æ‰§è¡ŒMCPå·¥å…·å¹¶è½¬æ¢ç»“æœæ ¼å¼"""
        try:
            # è°ƒç”¨MCPå·¥å…·
            result = await self.server_manager.call_tool(
                self.mcp_tool.server_name,
                self.mcp_tool.name,
                input_data.dict()
            )
            
            # è½¬æ¢MCPç»“æœåˆ°SimaCode ToolResult
            yield self._convert_mcp_result(result)
            
        except Exception as e:
            yield ToolResult(
                type=ToolResultType.ERROR,
                content=f"MCP tool execution failed: {str(e)}",
                tool_name=self.name
            )
```

## ğŸ“… åˆ†é˜¶æ®µå®ç°è®¡åˆ’

### Phase 1: MCPåè®®åŸºç¡€ (2-3å‘¨)
**ç›®æ ‡**: å»ºç«‹MCPåè®®é€šä¿¡åŸºç¡€

#### Week 1: åè®®å®ç°
- [ ] **MCPåè®®æ¶ˆæ¯ç»“æ„** (`mcp/protocol.py`)
  ```python
  @dataclass
  class MCPMessage:
      jsonrpc: str = "2.0"
      id: Optional[Union[str, int]] = None
      method: Optional[str] = None
      params: Optional[Dict] = None
      result: Optional[Any] = None
      error: Optional[Dict] = None
  
  class MCPProtocol:
      async def send_message(self, message: MCPMessage) -> None
      async def receive_message(self) -> MCPMessage
      async def call_method(self, method: str, params: Dict) -> Any
  ```

- [ ] **åŸºç¡€è¿æ¥ç®¡ç†**
  ```python
  class MCPConnection:
      def __init__(self, transport_type: str, config: Dict)
      async def connect(self) -> bool
      async def disconnect(self) -> None
      async def send(self, data: bytes) -> None
      async def receive(self) -> bytes
  ```

#### Week 2: å®¢æˆ·ç«¯æ ¸å¿ƒ
- [ ] **MCPå®¢æˆ·ç«¯å®ç°** (`mcp/client.py`)
- [ ] **è¿æ¥æµ‹è¯•å’Œè°ƒè¯•**
- [ ] **åŸºç¡€é”™è¯¯å¤„ç†**

#### Week 3: é›†æˆæµ‹è¯•
- [ ] **ä¸ç°æœ‰MCPæœåŠ¡å™¨æµ‹è¯•** (å¦‚å®˜æ–¹demoæœåŠ¡å™¨)
- [ ] **åè®®å…¼å®¹æ€§éªŒè¯**

### Phase 2: æœåŠ¡å™¨ç®¡ç†å’Œå·¥å…·å‘ç° (2-3å‘¨)
**ç›®æ ‡**: å®ç°å¤šMCPæœåŠ¡å™¨ç®¡ç†å’Œå·¥å…·å‘ç°

#### Week 4: æœåŠ¡å™¨ç®¡ç†
- [ ] **MCPServerManagerå®ç°**
  ```python
  class MCPServerManager:
      async def add_server(self, name: str, config: MCPServerConfig)
      async def list_servers(self) -> List[str]
      async def get_server_status(self, name: str) -> MCPServerStatus
      async def restart_server(self, name: str) -> bool
  ```

- [ ] **é…ç½®ç®¡ç†** (`mcp/config.py`)
  ```yaml
  # config/mcp_servers.yaml
  servers:
    github:
      type: "subprocess"
      command: ["node", "/path/to/github-mcp-server"]
      args: ["--token", "${GITHUB_TOKEN}"]
      
    filesystem:
      type: "subprocess" 
      command: ["python", "/path/to/filesystem-server"]
      args: ["--root", "/workspace"]
  ```

#### Week 5: å·¥å…·å‘ç°
- [ ] **å·¥å…·å‘ç°æœºåˆ¶**
  ```python
  async def discover_tools(self) -> List[MCPTool]:
      """å‘ç°æ‰€æœ‰MCPæœåŠ¡å™¨çš„å·¥å…·"""
      
  async def refresh_tools(self) -> None:
      """åˆ·æ–°å·¥å…·åˆ—è¡¨"""
  ```

- [ ] **å·¥å…·å…ƒæ•°æ®ç¼“å­˜**
- [ ] **å·¥å…·èƒ½åŠ›åˆ†æ**

#### Week 6: å¥åº·æ£€æŸ¥
- [ ] **æœåŠ¡å™¨å¥åº·ç›‘æ§**
- [ ] **è‡ªåŠ¨é‡è¿æœºåˆ¶**
- [ ] **æ•…éšœè½¬ç§»é€»è¾‘**

### Phase 3: å·¥å…·é›†æˆå’Œæ³¨å†Œ (2å‘¨)
**ç›®æ ‡**: å°†MCPå·¥å…·æ— ç¼é›†æˆåˆ°SimaCodeå·¥å…·ç³»ç»Ÿ

#### Week 7: å·¥å…·åŒ…è£…å™¨
- [ ] **MCPToolWrapperå®Œæ•´å®ç°**
  ```python
  class MCPToolWrapper(Tool):
      def _convert_input(self, input_data: ToolInput) -> Dict
      def _convert_output(self, mcp_result: MCPResult) -> ToolResult
      async def validate_input(self, input_data: ToolInput) -> bool
  ```

- [ ] **è¾“å…¥è¾“å‡ºæ ¼å¼è½¬æ¢**
- [ ] **é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶**

#### Week 8: è‡ªåŠ¨æ³¨å†Œ
- [ ] **MCPå·¥å…·è‡ªåŠ¨æ³¨å†Œ**
  ```python
  class MCPToolRegistry:
      async def register_mcp_tools(self) -> None:
          """è‡ªåŠ¨å‘ç°å¹¶æ³¨å†Œæ‰€æœ‰MCPå·¥å…·"""
          
      async def unregister_server_tools(self, server_name: str) -> None:
          """æ³¨é”€æŒ‡å®šæœåŠ¡å™¨çš„æ‰€æœ‰å·¥å…·"""
  ```

- [ ] **å·¥å…·å‘½åç©ºé—´ç®¡ç†** (é¿å…åç§°å†²çª)
- [ ] **åŠ¨æ€å·¥å…·æ›´æ–°**

### Phase 4: é«˜çº§åŠŸèƒ½ (2-3å‘¨)
**ç›®æ ‡**: å®ç°èµ„æºè®¿é—®ã€æç¤ºæ¨¡æ¿å’Œé«˜çº§é…ç½®

#### Week 9: èµ„æºæ”¯æŒ
- [ ] **MCPèµ„æºè®¿é—®**
  ```python
  class MCPResourceTool(Tool):
      """è®¿é—®MCPèµ„æºçš„ä¸“ç”¨å·¥å…·"""
      async def read_resource(self, uri: str) -> str
      async def list_resources(self, prefix: str) -> List[str]
  ```

#### Week 10: æç¤ºæ¨¡æ¿
- [ ] **MCPæç¤ºæ¨¡æ¿é›†æˆ**
  ```python
  class MCPPromptManager:
      async def get_prompt(self, name: str) -> MCPPrompt
      async def render_prompt(self, name: str, args: Dict) -> str
  ```

#### Week 11: é…ç½®å¢å¼º
- [ ] **ç¯å¢ƒå˜é‡æ³¨å…¥**
- [ ] **å®‰å…¨é…ç½®éªŒè¯**
- [ ] **æƒé™æ§åˆ¶é›†æˆ**

### Phase 5: é”™è¯¯å¤„ç†å’Œç›‘æ§ (1-2å‘¨)
**ç›®æ ‡**: å®Œå–„é”™è¯¯å¤„ç†ã€æ—¥å¿—è®°å½•å’Œæ€§èƒ½ç›‘æ§

#### Week 12: é”™è¯¯å¤„ç†
- [ ] **MCPä¸“ç”¨å¼‚å¸¸ä½“ç³»**
  ```python
  class MCPException(Exception): pass
  class MCPConnectionError(MCPException): pass
  class MCPToolNotFoundError(MCPException): pass
  class MCPTimeoutError(MCPException): pass
  ```

- [ ] **ä¼˜é›…é™çº§æœºåˆ¶**
- [ ] **é”™è¯¯æ¢å¤ç­–ç•¥**

#### Week 13: ç›‘æ§å’Œæ—¥å¿—
- [ ] **MCPæ“ä½œæ—¥å¿—è®°å½•**
- [ ] **æ€§èƒ½æŒ‡æ ‡æ”¶é›†**
- [ ] **è°ƒè¯•ä¿¡æ¯è¾“å‡º**

## ğŸ”§ æŠ€æœ¯éš¾ç‚¹åˆ†æä¸è§£å†³æ–¹æ¡ˆ

### 1. **MCPåè®®å®ç°å¤æ‚æ€§** ğŸ”´

**éš¾ç‚¹åˆ†æ:**
- MCPåŸºäºJSON-RPC 2.0ï¼Œéœ€è¦æ­£ç¡®å¤„ç†è¯·æ±‚/å“åº”/é€šçŸ¥
- æ”¯æŒå¤šç§ä¼ è¾“æ–¹å¼ (stdio, WebSocket, HTTP)
- åè®®ç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜

**è§£å†³æ–¹æ¡ˆ:**
```python
# åè®®æŠ½è±¡å±‚è®¾è®¡
class MCPTransport(ABC):
    @abstractmethod
    async def send(self, message: bytes) -> None: pass
    
    @abstractmethod
    async def receive(self) -> bytes: pass

class StdioTransport(MCPTransport):
    """æ ‡å‡†è¾“å…¥è¾“å‡ºä¼ è¾“"""
    
class WebSocketTransport(MCPTransport):
    """WebSocketä¼ è¾“"""
    
class MCPClient:
    def __init__(self, transport: MCPTransport):
        self.transport = transport
        self.protocol = JSONRPCProtocol(transport)
```

**æŠ€æœ¯è¦ç‚¹:**
- ä½¿ç”¨ç­–ç•¥æ¨¡å¼æ”¯æŒå¤šç§ä¼ è¾“æ–¹å¼
- å®ç°æ ‡å‡†JSON-RPC 2.0åè®®å¤„ç†
- åè®®ç‰ˆæœ¬åå•†æœºåˆ¶

### 2. **å¼‚æ­¥å¹¶å‘å¤„ç†** ğŸ”´

**éš¾ç‚¹åˆ†æ:**
- å¤šä¸ªMCPæœåŠ¡å™¨åŒæ—¶è¿æ¥
- å·¥å…·è°ƒç”¨çš„å¹¶å‘æ‰§è¡Œ
- è¿æ¥çŠ¶æ€ç®¡ç†çš„ç«æ€æ¡ä»¶

**è§£å†³æ–¹æ¡ˆ:**
```python
class MCPServerManager:
    def __init__(self):
        self.servers = {}
        self.connection_locks = {}
        self.executor = asyncio.Semaphore(10)  # é™åˆ¶å¹¶å‘æ•°
    
    async def call_tool_concurrent(self, calls: List[MCPToolCall]) -> List[MCPResult]:
        """å¹¶å‘æ‰§è¡Œå¤šä¸ªå·¥å…·è°ƒç”¨"""
        tasks = []
        for call in calls:
            async with self.executor:
                task = asyncio.create_task(
                    self._safe_call_tool(call.server, call.tool, call.args)
                )
                tasks.append(task)
        
        return await asyncio.gather(*tasks, return_exceptions=True)
```

**æŠ€æœ¯è¦ç‚¹:**
- ä½¿ç”¨asyncio.Semaphoreæ§åˆ¶å¹¶å‘åº¦
- è¿æ¥çŠ¶æ€ä½¿ç”¨å¼‚æ­¥é”ä¿æŠ¤
- å®ç°ä¼˜é›…çš„è¶…æ—¶å’Œå–æ¶ˆæœºåˆ¶

### 3. **è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†** ğŸŸ¡

**éš¾ç‚¹åˆ†æ:**
- MCPæœåŠ¡å™¨ä½œä¸ºå­è¿›ç¨‹å¯åŠ¨/åœæ­¢
- è¿›ç¨‹å´©æºƒæ£€æµ‹å’Œè‡ªåŠ¨é‡å¯
- èµ„æºæ¸…ç†å’Œå†…å­˜æ³„æ¼é˜²æ­¢

**è§£å†³æ–¹æ¡ˆ:**
```python
class MCPProcessManager:
    def __init__(self):
        self.processes = {}
        self.health_checker = asyncio.create_task(self._health_check_loop())
    
    async def start_server(self, name: str, config: MCPServerConfig) -> bool:
        """å¯åŠ¨MCPæœåŠ¡å™¨è¿›ç¨‹"""
        try:
            process = await asyncio.create_subprocess_exec(
                *config.command,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            self.processes[name] = MCPProcess(process, config)
            return True
        except Exception as e:
            logger.error(f"Failed to start MCP server {name}: {e}")
            return False
    
    async def _health_check_loop(self):
        """å¥åº·æ£€æŸ¥å¾ªç¯"""
        while True:
            for name, mcp_process in self.processes.items():
                if mcp_process.process.returncode is not None:
                    # è¿›ç¨‹å·²é€€å‡ºï¼Œå°è¯•é‡å¯
                    await self._restart_server(name)
            await asyncio.sleep(30)  # 30ç§’æ£€æŸ¥ä¸€æ¬¡
```

### 4. **é”™è¯¯å¤„ç†å’Œæ¢å¤** ğŸŸ¡

**éš¾ç‚¹åˆ†æ:**
- ç½‘ç»œè¿æ¥å¤±è´¥
- MCPæœåŠ¡å™¨å“åº”è¶…æ—¶
- å·¥å…·æ‰§è¡Œå¼‚å¸¸
- éƒ¨åˆ†æœåŠ¡å™¨ä¸å¯ç”¨æ—¶çš„é™çº§å¤„ç†

**è§£å†³æ–¹æ¡ˆ:**
```python
class MCPErrorHandler:
    def __init__(self, max_retries: int = 3, backoff_factor: float = 2.0):
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
    
    async def with_retry(self, func: Callable, *args, **kwargs):
        """å¸¦é‡è¯•çš„å‡½æ•°æ‰§è¡Œ"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                return await func(*args, **kwargs)
            except (MCPConnectionError, MCPTimeoutError) as e:
                last_exception = e
                if attempt < self.max_retries - 1:
                    delay = self.backoff_factor ** attempt
                    await asyncio.sleep(delay)
                    continue
                break
            except MCPToolNotFoundError:
                # å·¥å…·ä¸å­˜åœ¨ï¼Œä¸é‡è¯•
                break
        
        raise last_exception

# ä½¿ç”¨ç¤ºä¾‹
error_handler = MCPErrorHandler()
result = await error_handler.with_retry(
    client.call_tool, "tool_name", {"arg": "value"}
)
```

### 5. **å®‰å…¨æ€§æ§åˆ¶** ğŸ”´

**éš¾ç‚¹åˆ†æ:**
- MCPæœåŠ¡å™¨å¯èƒ½æ‰§è¡Œä»»æ„ç³»ç»Ÿå‘½ä»¤
- æ–‡ä»¶ç³»ç»Ÿè®¿é—®æƒé™æ§åˆ¶
- ç½‘ç»œè®¿é—®é™åˆ¶

**è§£å†³æ–¹æ¡ˆ:**
```python
class MCPSecurityManager:
    def __init__(self, security_config: SecurityConfig):
        self.allowed_commands = security_config.allowed_commands
        self.forbidden_paths = security_config.forbidden_paths
        self.network_policy = security_config.network_policy
    
    def validate_server_config(self, config: MCPServerConfig) -> bool:
        """éªŒè¯MCPæœåŠ¡å™¨é…ç½®çš„å®‰å…¨æ€§"""
        # æ£€æŸ¥å‘½ä»¤æ˜¯å¦åœ¨å…è®¸åˆ—è¡¨ä¸­
        if config.command[0] not in self.allowed_commands:
            raise SecurityError(f"Command {config.command[0]} not allowed")
        
        # æ£€æŸ¥å‚æ•°ä¸­çš„è·¯å¾„
        for arg in config.args:
            if self._contains_forbidden_path(arg):
                raise SecurityError(f"Forbidden path in arguments: {arg}")
        
        return True
    
    async def validate_tool_call(self, tool_name: str, arguments: Dict) -> bool:
        """éªŒè¯å·¥å…·è°ƒç”¨çš„å®‰å…¨æ€§"""
        # å¯ä»¥é›†æˆåˆ°ç°æœ‰çš„æƒé™ç³»ç»Ÿ
        return await self.permission_manager.check_tool_permission(
            tool_name, arguments
        )
```

### 6. **æ€§èƒ½ä¼˜åŒ–** ğŸŸ¡

**éš¾ç‚¹åˆ†æ:**
- å¤šä¸ªMCPæœåŠ¡å™¨çš„è¿æ¥å¼€é”€
- å·¥å…·è°ƒç”¨çš„å»¶è¿Ÿä¼˜åŒ–
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–

**è§£å†³æ–¹æ¡ˆ:**
```python
class MCPPerformanceOptimizer:
    def __init__(self):
        self.tool_cache = TTLCache(maxsize=1000, ttl=300)  # 5åˆ†é’Ÿç¼“å­˜
        self.connection_pool = {}
        
    async def cached_tool_call(self, server: str, tool: str, args: Dict) -> MCPResult:
        """å¸¦ç¼“å­˜çš„å·¥å…·è°ƒç”¨"""
        cache_key = self._generate_cache_key(server, tool, args)
        
        if cache_key in self.tool_cache:
            return self.tool_cache[cache_key]
        
        result = await self._actual_tool_call(server, tool, args)
        
        # åªç¼“å­˜æˆåŠŸçš„ç»“æœ
        if result.success:
            self.tool_cache[cache_key] = result
            
        return result
    
    def _generate_cache_key(self, server: str, tool: str, args: Dict) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        args_hash = hashlib.md5(
            json.dumps(args, sort_keys=True).encode()
        ).hexdigest()
        return f"{server}:{tool}:{args_hash}"
```

## ğŸ¯ å®æ–½å»ºè®®å’Œé…ç½®ç¤ºä¾‹

### é…ç½®æ–‡ä»¶ç»“æ„
```yaml
# config/mcp_servers.yaml
mcp:
  enabled: true
  timeout: 30
  max_concurrent: 10
  
servers:
  # GitHubé›†æˆ
  github:
    enabled: true
    type: "subprocess"
    command: ["npx", "@modelcontextprotocol/server-github"]
    args: ["--token", "${GITHUB_TOKEN}"]
    environment:
      GITHUB_TOKEN: "${GITHUB_TOKEN}"
    security:
      allowed_operations: ["read_repository", "list_issues", "create_issue"]
      
  # æ–‡ä»¶ç³»ç»Ÿè®¿é—®
  filesystem:
    enabled: true
    type: "subprocess"
    command: ["python", "-m", "mcp_server_filesystem"]
    args: ["--root", "/workspace"]
    security:
      allowed_paths: ["/workspace", "/tmp"]
      forbidden_paths: ["/etc", "/usr", "/sys"]
      
  # æ•°æ®åº“è¿æ¥
  postgres:
    enabled: false
    type: "subprocess" 
    command: ["node", "mcp-server-postgres"]
    args: ["--connection-string", "${DATABASE_URL}"]
    environment:
      DATABASE_URL: "${DATABASE_URL}"
```

### ä½¿ç”¨ç¤ºä¾‹
```python
# åœ¨ReActå¼•æ“ä¸­ä½¿ç”¨MCPå·¥å…·
async def demo_mcp_integration():
    # 1. åˆå§‹åŒ–MCPç®¡ç†å™¨
    mcp_manager = MCPServerManager()
    await mcp_manager.load_servers_from_config()
    
    # 2. è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰MCPå·¥å…·
    mcp_registry = MCPToolRegistry(mcp_manager)
    await mcp_registry.register_all_tools()
    
    # 3. ReActå¼•æ“ç°åœ¨å¯ä»¥ä½¿ç”¨MCPå·¥å…·
    available_tools = ToolRegistry.list_tools()
    # è¾“å‡º: ['file_read', 'bash', 'mcp_github_list_repos', 'mcp_filesystem_read_file', ...]
    
    # 4. é€šè¿‡ReActå¼•æ“è°ƒç”¨
    react_engine = ReActEngine(ai_client)
    await react_engine.process_user_input(
        "List all repositories in my GitHub account and read the README.md file"
    )
```

## ğŸ“Š å®æ–½ä¼˜å…ˆçº§å»ºè®®

### ğŸ”¥ ç«‹å³å¼€å§‹ (Phase 1)
**å»ºè®®åŸå› **: MCPç”Ÿæ€ç³»ç»Ÿå¿«é€Ÿå‘å±•ï¼Œæ—©æœŸé‡‡ç”¨è€…ä¼˜åŠ¿æ˜æ˜¾

1. **å…ˆå®ç°stdioä¼ è¾“æ–¹å¼** - æœ€ç®€å•ï¼Œå¤§å¤šæ•°MCPæœåŠ¡å™¨æ”¯æŒ
2. **é›†æˆ2-3ä¸ªæ ¸å¿ƒMCPæœåŠ¡å™¨** - GitHubã€æ–‡ä»¶ç³»ç»Ÿã€Shellå‘½ä»¤
3. **åŸºç¡€å·¥å…·åŒ…è£…å’Œæ³¨å†Œæœºåˆ¶**

### ğŸ“ˆ æŠ€æœ¯æ”¶ç›Šè¯„ä¼°

| æ”¶ç›Šç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|---------|------|------|
| **å¼€å‘æ•ˆç‡** | â­â­â­â­â­ | å¤ç”¨å¤§é‡ç°æœ‰MCPå·¥å…·ï¼Œæ— éœ€é‡å¤å¼€å‘ |
| **ç”Ÿæ€æ‰©å±•** | â­â­â­â­â­ | æ¥å…¥å¿«é€Ÿå¢é•¿çš„MCPç”Ÿæ€ç³»ç»Ÿ |
| **æ ‡å‡†åŒ–** | â­â­â­â­ | ä½¿ç”¨ä¸šç•Œæ ‡å‡†åè®®ï¼Œç¡®ä¿äº’æ“ä½œæ€§ |
| **ç»´æŠ¤æˆæœ¬** | â­â­â­ | éœ€è¦ç»´æŠ¤MCPå®¢æˆ·ç«¯ï¼Œä½†å·¥å…·ç»´æŠ¤æˆæœ¬ä½ |
| **å­¦ä¹ æ›²çº¿** | â­â­â­ | MCPåè®®ç›¸å¯¹å¤æ‚ï¼Œä½†æ–‡æ¡£å®Œå–„ |

## ğŸš€ å…³é”®æˆåŠŸå› ç´ 

1. **åè®®æ­£ç¡®æ€§**: ä¸¥æ ¼æŒ‰ç…§MCPè§„èŒƒå®ç°ï¼Œç¡®ä¿å…¼å®¹æ€§
2. **é”™è¯¯æ¢å¤**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨é‡è¿æœºåˆ¶
3. **å®‰å…¨æ§åˆ¶**: é›†æˆåˆ°ç°æœ‰å®‰å…¨æ¡†æ¶ï¼Œé˜²æ­¢æ¶æ„ä»£ç æ‰§è¡Œ
4. **æ€§èƒ½ä¼˜åŒ–**: è¿æ¥æ± ã€ç¼“å­˜å’Œå¹¶å‘æ§åˆ¶
5. **é€æ­¥æ¨è¿›**: å…ˆå®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œå†é€æ­¥å®Œå–„é«˜çº§ç‰¹æ€§

## ğŸ”® é•¿æœŸæ„¿æ™¯

é€šè¿‡MCPé›†æˆï¼ŒSimaCodeå°†æˆä¸ºï¼š
- **å·¥å…·èšåˆå™¨**: ç»Ÿä¸€è®¿é—®å„ç§ä¸“ä¸šå·¥å…·
- **åè®®æ¡¥æ¢**: è¿æ¥ä¸åŒçš„å¼€å‘å·¥å…·ç”Ÿæ€
- **æ™ºèƒ½è·¯ç”±**: æ ¹æ®ä»»åŠ¡è‡ªåŠ¨é€‰æ‹©æœ€åˆé€‚çš„å·¥å…·
- **ç”Ÿæ€ä¸­å¿ƒ**: ä¸ºDevGenius Agentæä¾›ä¸°å¯Œçš„å·¥å…·èƒ½åŠ›

## ğŸ“¦ ä¾èµ–å’ŒæŠ€æœ¯è¦æ±‚

### æ–°å¢Pythonä¾èµ–
```toml
# pyproject.toml
[tool.poetry.dependencies]
# MCPç›¸å…³ä¾èµ–
websockets = "^11.0.3"          # WebSocketä¼ è¾“æ”¯æŒ
pydantic = "^2.5.0"             # å·²å­˜åœ¨ï¼Œç”¨äºæ•°æ®éªŒè¯
asyncio-subprocess = "^0.1.0"   # å¼‚æ­¥å­è¿›ç¨‹ç®¡ç†
cachetools = "^5.3.2"           # ç¼“å­˜æ”¯æŒ
jsonrpc-base = "^2.2.0"         # JSON-RPCåŸºç¡€å®ç°
```

### å¤–éƒ¨å·¥å…·ä¾èµ–
```bash
# å¸¸ç”¨MCPæœåŠ¡å™¨
npm install -g @modelcontextprotocol/server-github
npm install -g @modelcontextprotocol/server-filesystem
pip install mcp-server-sqlite
```

## ğŸ“‹ é¡¹ç›®é‡Œç¨‹ç¢‘

### Milestone 1: åŸºç¡€åè®®å®ç° (Week 1-3)
- [ ] MCPåè®®æ¶ˆæ¯å¤„ç†
- [ ] stdioä¼ è¾“å±‚å®ç°
- [ ] åŸºç¡€å®¢æˆ·ç«¯è¿æ¥

### Milestone 2: æœåŠ¡å™¨ç®¡ç† (Week 4-6)
- [ ] å¤šæœåŠ¡å™¨ç®¡ç†
- [ ] é…ç½®æ–‡ä»¶æ”¯æŒ
- [ ] å¥åº·æ£€æŸ¥æœºåˆ¶

### Milestone 3: å·¥å…·é›†æˆ (Week 7-8)
- [ ] å·¥å…·åŒ…è£…å™¨å®ç°
- [ ] è‡ªåŠ¨æ³¨å†Œæœºåˆ¶
- [ ] ReActå¼•æ“é›†æˆ

### Milestone 4: é«˜çº§åŠŸèƒ½ (Week 9-11)
- [ ] èµ„æºè®¿é—®æ”¯æŒ
- [ ] æç¤ºæ¨¡æ¿é›†æˆ
- [ ] å®‰å…¨é…ç½®å®Œå–„

### Milestone 5: ç”Ÿäº§å°±ç»ª (Week 12-13)
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] ç›‘æ§å’Œæ—¥å¿—

è¿™ä¸ªMCPé›†æˆæ–¹æ¡ˆå°†æ˜¾è‘—æå‡SimaCodeçš„ç«äº‰åŠ›ï¼Œä½¿å…¶æˆä¸ºä¸€ä¸ªçœŸæ­£å¯æ‰©å±•çš„AIç¼–ç¨‹åŠ©æ‰‹å¹³å°ã€‚å»ºè®®ä¼˜å…ˆå¯åŠ¨Phase 1çš„å®ç°ï¼Œä¸ºæ•´ä¸ªDevGeniusç”Ÿæ€ç³»ç»Ÿå¥ å®šå¼ºå¤§çš„å·¥å…·åŸºç¡€ã€‚